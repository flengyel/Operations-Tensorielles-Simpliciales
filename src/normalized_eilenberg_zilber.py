# normalized_eilenberg_zilber.py
# computes the differentials and basis for the Eilenberg-Zilber 
# chain complex for the relative homology $𝐻_𝑛(N(𝑉∙(𝑇)),N(𝐿)∙)$
# for a given shape $s=(n_1,...,n_k)$ and horn index $j$ using numpy
# The complex comes from the k-way simplicial abelian group
# generated by the tensor T.
# 
# The Dold-Kan normalization projector is used to ensure that
# the standard basis tensors at the missing indices are non-degenerate 
# and form a basis for the relative homology group.

# The normalize tensor loop compues the normalization projector
# $P = \Product_{i=0}^{n-1}\Product_{\mathrm{axis}=1}^{k} (1 - s_i d_i)$
# Once normalized, the elementary tensors $E_{i_1,...,i_k}$ at the
# missing indices will form a basis for the relative homology group.
# The Eilenberg-Zilber total differential is computed with the
# Koszul sign convention, which combines the face maps on each axis.
# The result is the chain complex whose homology matches the combinatorial count.

import numpy as np
import itertools

# ==============================================================================
# 1. Core Simplicial Operators (Axis-wise)
# ==============================================================================

def face(T, axis, i):
    """Removes slice i from the specified axis."""
    if not (0 <= i < T.shape[axis]):
        raise IndexError(f"Face index {i} is out of bounds for axis {axis} with size {T.shape[axis]}")
    return np.delete(T, i, axis=axis)

def degen(T, axis, i):
    """Duplicates slice i along the specified axis by inserting it at position i."""
    if not (0 <= i < T.shape[axis]):
        raise IndexError(f"Degen index {i} is out of bounds for axis {axis} with size {T.shape[axis]}")
    return np.insert(T, i, T.take(i, axis=axis), axis=axis)

# ==============================================================================
# 2. Corrected Normalization Projector
# ==============================================================================

def normalize_tensor(M):
    P = M.copy()
    n = min(P.shape) - 1
    if n < 0:
        return P

    # for each face index i, remove the *diagonal* s_i d_i correction:
    for i in range(n-1, -1, -1):
        # compute diagonal d_i(P):
        # apply face i on *every* axis simultaneously
        dP = P
        for ax in range(P.ndim):
            dP = face(dP, ax, i)
        # then re‑insert via the *same* degeneracy on every axis
        sPd = dP
        for ax in range(P.ndim):
            sPd = degen(sPd, ax, i)
        # subtract just once
        P = P - sPd

    return P

# ==============================================================================
# 3. Main Basis Construction Algorithm
# ==============================================================================

def get_missing_indices(shape, j):
    """Computes the set of index tuples that are 'missing' from the j-th horn."""
    n = min(shape) - 1
    if not (0 <= j <= n): raise ValueError(f"Horn index {j} out of bounds")
    horn_face_indices = set(range(n + 1)) - {j}
    missing_indices = [
        idx for idx in itertools.product(*(range(s) for s in shape))
        if horn_face_indices.issubset(set(idx))
    ]
    return missing_indices

def construct_homology_basis(shape, j):
    """
    Constructs a basis for the relative homology group H_n(A, L_j) by
    creating and normalizing an elementary tensor for each missing index.
    """
    n = min(shape) - 1
    missing_indices = get_missing_indices(shape, j)
    basis_vectors = []
    print(f"Found {len(missing_indices)} missing indices for horn Λ^{n}_{j}. Constructing basis...")
    for idx in missing_indices:
        Z = np.zeros(shape, dtype=int)
        Z[idx] = 1
        # Project Z onto the space of non-degenerate chains.
        normalized_Z = normalize_tensor(Z)
        basis_vectors.append(normalized_Z)
    return basis_vectors

# ==============================================================================
# 4. Eilenberg-Zilber Chain Complex Builder
# ==============================================================================

def build_ez_chain_complex(basis_map: dict, max_dim: int):
    """
    Builds the chain complex for a tensor product space using the
    Eilenberg-Zilber total differential with the correct Koszul sign.
    """
    differentials = {}
    if not any(basis_map.values()): return differentials
    
    # Get the order of the tensor from a sample basis element
    # Find the first non-empty basis to get a sample tensor
    sample_tensor = None
    for k in sorted(basis_map.keys()):
        if basis_map[k]:
            sample_tensor = basis_map[k][0]
            break
    if sample_tensor is None: return differentials
    num_axes = len(sample_tensor.shape)

    for k in range(1, max_dim + 2):
        C_k = basis_map.get(k, [])
        C_km1 = basis_map.get(k - 1, [])
        if not C_k or not C_km1: continue
        
        C_km1_indices = {t.tobytes(): i for i, t in enumerate(C_km1)}
        total_d_k = np.zeros((len(C_km1), len(C_k)), dtype=int)

        for axis in range(num_axes):
            d_k_axis = np.zeros((len(C_km1), len(C_k)), dtype=int)
            for j_col, t_k in enumerate(C_k):
                for i_face in range(k + 1):
                    try:
                        face_t_axis = face(t_k, axis, i_face)
                        key_f = face_t_axis.tobytes()
                        if key_f in C_km1_indices:
                            row_idx = C_km1_indices[key_f]
                            d_k_axis[row_idx, j_col] += (-1)**i_face
                    except IndexError:
                        continue
            
            sign = (-1)**axis
            total_d_k += sign * d_k_axis

        differentials[k] = total_d_k
        
    return differentials

# ==============================================================================
# 5. Test and Verification Suite
# ==============================================================================

if __name__ == '__main__':
    shapes = [(2,2),(3, 3),(3,3,3),(4,4,4)]

    for shape in shapes:
        n = min(shape) - 1
        j = 1

        print(f"--- Full Homological Test for shape={shape}, horn=Λ^{n}_{j} ---")

        basis = construct_homology_basis(shape, j)
        
        if not basis:
            print("No basis vectors were generated. Rank is 0.")
        else:
            flat_vectors = [v.flatten() for v in basis]
            matrix_to_test = np.array(flat_vectors)
            rank = np.linalg.matrix_rank(matrix_to_test)
            
            print(f"\n--- Verification ---")
            print(f"Number of basis vectors generated: {len(basis)}")
            print(f"Rank of the basis matrix: {rank}")
            
            if len(basis) == rank:
                print(f"\n✅ SUCCESS: The generated basis is linearly independent.")
                print(f"   The computed combinatorial rank is {rank}.")
            else:
                print(f"\n❌ FAILURE: The generated basis is linearly dependent.")

